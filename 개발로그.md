# 개발/설계중 나오는 팁이나 논쟁거리에 대해 이야기합니다.

# 도메인 interface 를 정의할때 엔티티를 직접 리턴하는 것은 문제가 없나?
- 아무 문제가 없다고 생각함. 의존관계나, 원칙, 성능이나 효용성 등 모든 면에서 문제가 없음
- 프레젠테이션 레이어에서 응답에 필요한 데이터를 꺼내서 잘 리턴하면 됨. (나중에 설명 예정)

# Spring Data Repository 와 Jpa Repository 와의 차이점은
- 스프링 데이터의 메소드를 만드는 관계가 있음
  - Entity save(Entity entity)
- 스프링 데이터는 어떤 데이터를 수정할때 호출한다는 관례를 따름
  - JPA는 새로운 엔티티 오브젝트를 생성, 영속화 아니면 준영속할때만 사용해서 좀 다름
  - 나중에 굉장히 중요한 역할을 할 것

# 코멘트(주석)
- 인터페이스의 메소드에도 코멘트가 필요할 때가 있음
  - 파라미터에 대한 설명
  - 실행하다가 발생할 수 있는 Exception
  - 예외적인 상황
## 클린코드에 위반되지 않는가?
- 전혀 아님. 
- 클린코드 저자가 코멘트에 대해 이야기할 코드를 엉망으로 만들고 그 잘못된 코드를 커버하기 위해 다는 코멘트(주석)을 쓰지 말라고 했음
- 따라서 인터페이스(포트)는 설명을 다하는 습관을 두는게 제일 중요함
  - 이를 API라고도 부름
  - API는 자신을 설명하는 문서를 작성하는것이 맞다.

# Password Encoder 에 대해서
- 회원 애플리케이션이 필요한 기능 중 패스워드 암소화가 있음
  - 도메인 안에 두기에는 너무 기술적이기 때문
  - 따라서 이를 required 인터페이스로 정의해야함
## 그러면 Domain의 Member에서 사용하는 PasswordEncoder 인터페이스를 Application 레이어에 옮겨야 하는가?
- 안됨.
- 도메인에서 애플리케이션 레이어를 의존하는 형태가 되어버리기 때문..
- 도메인 모델을 표현하는 도메인 서비스를 인터페이스만 만들고 
  - 그 도메인 서비스 로직을 둘수 없을 때는 
  - 결국 도메인 레이어에서 필요한 기능이기 때문에 
  - 해당 인터페이스를 도메인에 두는 것이 맞음.


# Entity
- 어떤 대상을 엔티티라고 부르려면 식별자를 가져야하는 것이 기본 조건
  - Member의 경우 email이 식별자가 됨. 이게 최선일까?
## 엔티티 식별자가 되기 위한 기준
- 고유성 (두 개의 엔티티가 같은 값을 가지면 안 됨)
- 불변성 (한번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다.)
  - 이를 참조 정합성이 훼손되고, 연관관계를 깨뜨린다.
- 비즈니스적인 의미로부터 디커플링 되는 것이 좋다.
> 따라서 이메일은 불변성을 깨뜨릴 수 있고, 비즈니스적인 의미가 강하기 때문에 식별자로 적합하지 않음
- 따라서 자연 키 대신 인조키(대리 키) 사용

## 도메인의 엔티티에 Jpa 관련 어노테이션을 붙이는 것
- 어노테이션은 그냥 주석일 뿐 의존성에 영향을 끼치지 않음
- 특정 기술에 종속적인 코드가 되지 않는다는 것.
- JPA를 안 쓰고 다른 기술을 쓴다고 해서 이 어노테이션이 문제가 되지 않음.
- 컴파일할때는 JPA 인터페이스가 필요하겠지만,, 런타임에서는 전혀 문제가 안 됨


# DataJpaTest
- Spring의 모든 빈을 다 띄우는게 아니라 Data Jpa가 동작할 수 있는 최소한의 빈들로만 구성해서 띄워줌
- 데이터베이스 연결을 기본적으로 h2 embedded DB를 사용해 메모리안에서 돌아가기때문에 DB를 따로 셋업 안해도 되고 굉장히 빠름
- jpa 표준을 따라 portable하게 만들어진 repository라면 이거 사용하면 됨.

# 비즈니스 적으로 유니크해야하는 자연키
- jpa 표준은 아니지만 hibernate 에서 지원하는 @NaturalId 어노테이션을 쓰면 unique 제약을 확인함
- 테스트 같은데서 자동으로 데이터베이스를 만드는 작업을 할때도 유니크 제약조건이 걸림
- @NaturalIdCache 는 자연 키 NaturalId를 캐싱해서 같은 같은 아이디 값을 가지고 한번 읽어온 것을 한번 더 읽어오면, DB에서 조회하지 않고 영속 컨텍스트에서 바로 꺼내올 수 있음.
  - NaturalId 를 적용했기 때문에 가능

# Lombok 사용에 대해서
- Lombok 사용하는 것을 싫어하는 사람이 많음
  - 왜? 이 롬복 어노테이션이 어떤 코드를 만드는지 몰라 이로 인해 사이드 이펙이 생길 수 있기 때문
  - 롬복이 어떤 코드를 만드는지 잘 인지하고 개발하자

# Application 서비스를 만들때
- 처음에 메소드를 구현할때 이 흐름(Flow)를 따라가기 위한 주석은 괜찮음.
- 중요한 것
  - 도메인은 도메인 모델을 설계하고 문서도 만들고 다이어 그램도 만들고 한것을 잘 반영했는가?
  - 애플리케이션 서비스는 실제로 서비스에서 사용하는 주요한 작업들을 어떤 절차를 거쳐 이 기능을 수행하는가? 누구와 협력을 하는가?가 코드 안에서 잘 읽힐 수 있어야함
- 시간이 지나 이 코드를 보며 애플리케이션 로직을 말로 잘 풀어낼 수 있으면 좋을 코드임
- 신경쓸 것
  - 앞으로 이러한 provided interface가 점점 더 늘어날 것인데
  - 회원과 관련해서 어떤 의도를 가지고 이 시스템을 쓰겠다라고 하면 이를 사용하는 클라이언트도 그 용도에 따라 여러가지로 분리될 수 있음
  - 인터페이스를 만들지 않고 클래스 하나만 만드는 경우 회원과 관련된 모든 기능들이 하나에 다 담기게 됨.
    - 따라서 이러한 기능을 분리하는 기준을 만들어야함
    - 의도에 따라 기능을 분리한 provided interface를 많이 이용하자.
- 계층형 아키텍처에서 한 계층이 다른 계층을 접근할때 인터페이스를 통해 접근한다 -> 당연한 것
 
# Application 테스트에 대하여
- provided interface에 대해 테스트를 진행
- 테스트를 진행하기 위해 required interface를 테스트해야함
  - repository -> memory db
  - 실제로 구현이 필요한 것, 리턴 객체가 필요한 것
    - stub, mock을 만들어 테스트
    - 몇번 호출되었는가? 등으로 간단한 테스트 가능
- 일반적으로 테스트는 구현에 대해서 하는 것이 아닌 인터페이스에 대해서 하는 것
  - 테스트를 통해 클래스, 기능을 쪼개는게 가능
- 기능이 달라지면 테스트도 같이 바뀌어야함
  - 그러나 기능이 크게 바뀌지 않았는데 리팩토링을 통해 테스트를 많이 바꿔야한다면 테스트 대상 설정을 잘못한게 아닌가 생각해야함
- 헥사고날 아키텍처, 스프링을 사용한다면 무조건 테스트해야함
  - 테스트가 용이한 아키텍쳐이기 때문
  - 클린코드에서도 강조하는 사항

## 테스트
- Stub
  - 아무 기능 없이 그냥 단순 구현 (아무 작업도 안함)
- Mock
  - Stub과 비슷하게 아무 기능이 없지만, 메소드 호출이나 호출 데이터 검증 등의 작업을 수행해야함
- Mockito
  - Mock 생성을 도와주는 테스트를 위한 라이브러리

### Spring Test
- 매번 Stub을 정의하여 테스트하는 것은 상당히 번거롭다.
- 그래서 스프링 프레임워크를 이용하여 최소한의 구성요소만 올려 간편하게 테스트 가능
- 테스트용 빈을 등록 하여 required interface를 구성 가능 
- 스프링 컨테이너가 동작하는 방식으로 테스트를 만드는게 애플리케이션 테스트에서는 훨신 편리하다.
  - 메뉴얼 테스트도 필요할수도 있음
  - 대부분의 경우에는 컨테이너를 띄우는 방식의 테스트가 훨씬 나음
  - 시간이 조금 더 걸리지만 최적화가 잘되어있음

### 테스트 코드에서의 Autowired
- Autowired 필드주입은 테스트 코드에서는 사용해도 상관 없음
- Autowired 가 많아질수록 코드가 많아지고 시선이 뺏김
  - 그래서 요즘은 테스트를 record로 만듦
    - Junit 공식 문서에 가능하다고 적혀 있음.
- 단 이를 사용하기 위해서 @TestConstructor 사용 해야함
  - 이조차 자동화하기 위해서 spring.test.constructor.autowire.mode=all 를 resources에 저장

## 서비스단의 흐름
- 진입점에 대한 버플릭 메소드에서는 추상적인 레벨로 안에서 어떤 작업이 일어난다 정도만 명시하는 것이 좋다.
- 메소드에는 동일 레벨의 로직이 있어야함. 하나라도 레벨이 어긋나면 잘못된 것.

## 서비스단의 검증에 대해서 (MemberService)
- MemberRegisterRequest 의 경우 입력에 대한 검증이 필요함
- 이 입력값은 Controller 단에서도 검증이 일어나고 도메인 레벨에서도 검증이 일어남
- Service 단에서도 검증이 필요한가?
  - 아무리 앞에서 검증을 잘 만들거라고 해도 신뢰하면 안됨
  - 도메인에서는 도메인 레벨에서의 최소한의 검증만 함
  - 애플리케이션으로 만들어지고 적용될때는 더 엄밀한 규칙들이 적용이 될 것
- 따라서 애플리케이션 레이어에서 검증을 하는 것이 제일 좋음.
- 입력 검증은 어디서 하는게 좋을까?
  - 입력 모델 내부에서 검증하는 것이 좋다!!
- Record에는 레코드 헤더에 정의된 값들을 가지고 검증할 수 있음
  - 컴팩트 캐노니컬 컨스트럭터를 통해 검증 로직 수행 가능
  - 그러나 이렇게 코드레벨로 하는것 보다,,,
- 어노테이션으로 선언적으로 하는 자바 표준을 사용하자
  - JSR-303 Bean Validation 규약
  - 이걸 검증하려면 이를 지원하는 프레임워크가 필
    - 스프링과 하이버네이트가 대표적임

### 표준 어노테이션을 통해 검증할 수 없는 조건들은 어떻게 해야할까?
- 2가지 방법이 있을 듯
- 표준 자바 밸리데이션 기능을 수행 가능하도록 커스텀 애노테이션 만들어 검증로직 부여
- 레코드에 생성자를 이용해 밸리데이션 하는 로직을 코드로 작성
  - 혹은 validate 메소드를 만들어서 애플리케이션 서비스에서 실행해주는 방식으로 해결

## Test Class도 record로 만들 수 있음
- 대신 @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
  - 를 붙여줘야한다는 단점이 있으나, 이건 junit-platform.properties 설정을 통해 전역적으로 적용 가능
    - spring.test.constructor.autowire.mode=all

## Spring 프레임워크에서 지원하는 JPA에는 왜 save() 메소드가 있는가
- 업데이트 상황에서도 save()를 호출해야함
  - 왜냐면 jpa만 적용되는 기능이 아니라 다양한 종류의 데이터 저장 기술을 지원하기 위해..
- 이 기술의 목적은 Repository를 추상화하기 위한 것.
  - 다른 저장기술을 사용하는 것과 동일하게 jpa에서도 save()를 호출해야함
  - jpa가 아닌 다른 저장 기술에도 범용적으로 추상화 하기 위한 것
- save를 진행하지 않으면? 
  - 스프링 데이터가 지원하는 기능 중 Domain Event Publication 이 일어나지 않음
    - 따라서 항상 업데이트를 할때도 세이브하는 습관을 들이자.
  - Auditing도 일어나지 않음

## 기능별로 인터페이스를 만들어라
- MemberRegister, MemberFinder 처럼 역할과 기능별로 인터페이스를 만들고 이를 구현하는 것이 좋다.
  - 변경과 조회 그리고 등록은 각각 다른 기능이다.
  - 하나에 모두 넣으면,,, 나중에 클래스가 너무 커짐
  - 분리 -> 리팩터링 = 테스트
    - 테스트는 인터페이스 단위로..
- findById로 주로 객체를 찾지만 이런 경우에 파라미터로 그냥 Long이 온다면 find(Long id)로 만든다고 함
- 조회 로직과 변경 로직을 담당하는 클래스도 분리하고 싶음
  - 왜? -> 시간이 지나면서 서로 의존하는 오브젝트들이 점점 달라지기 때문..
  - 변경없이 조회만하는 기능과 변경이 일어나는 기능 두가지로 구분하면 좋을 듯.
    - 이런 컨셉을 잘 설명하는 객체지향적 원리 **CQS(Command Query Separation)**
      - 그러나 Command는 너무 강한 표현이니... 이걸 Modify로 순화
    - 조회 - MemberQueryService
    - 변경 - MemberModifyService 

## 리팩토링 이후에는 항상 변경된 코드들을 보고 더 개선지점이 없는지 파악해보자.
- 테스트 커버리지도 확인해보자.
- 커버리지 체크 -> run test with coverage로 확인 가능
  - 테스트 커버리지는 100% 만드는거에 집착하지 말자.
  - 리스크가 있는 코드에 대해서 반드시 작성하기만 하면 됨

